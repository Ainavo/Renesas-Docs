import{_ as n,o as s,c as a,e}from"./app-829098b3.js";const t={},p=e(`<h1 id="第18章-调试与优化" tabindex="-1"><a class="header-anchor" href="#第18章-调试与优化" aria-hidden="true">#</a> 第18章 调试与优化</h1><h2 id="_18-1-调试" tabindex="-1"><a class="header-anchor" href="#_18-1-调试" aria-hidden="true">#</a> 18.1 调试</h2><p>FreeRTOS提供了很多调试手段：</p><ul><li>打印</li><li>断言：configASSERT</li><li>Trace</li><li>Hook函数(回调函数)</li></ul><h3 id="_18-1-1-打印" tabindex="-1"><a class="header-anchor" href="#_18-1-1-打印" aria-hidden="true">#</a> 18.1.1 打印</h3><p>printf：FreeRTOS工程里使用了microlib，里面实现了printf函数。</p><p>我们只需实现一下函数即可使用printf：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">fputc</span><span class="token punctuation">(</span> <span class="token keyword">int</span> ch<span class="token punctuation">,</span> FILE <span class="token operator">*</span>f <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_18-1-2-断言" tabindex="-1"><a class="header-anchor" href="#_18-1-2-断言" aria-hidden="true">#</a> 18.1.2 断言</h3><p>一般的C库里面，断言就是一个函数：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">assert</span><span class="token punctuation">(</span>scalar expression<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>它的作用是：确认expression必须为真，如果expression为假的话就中止程序。</p><p>在FreeRTOS里，使用configASSERT()，比如：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>##define <span class="token function">configASSERT</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们可以让它提供更多信息，比如：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>##define <span class="token function">configASSERT</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  \\
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> \\
	<span class="token punctuation">{</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s %s %d\\r\\n&quot;</span><span class="token punctuation">,</span> <span class="token constant">__FILE__</span><span class="token punctuation">,</span> __FUNCTION__<span class="token punctuation">,</span> <span class="token constant">__LINE__</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \\
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \\
 	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>configASSERT(x)中，如果x为假，表示发生了很严重的错误，必须停止系统的运行。</p><p>它用在很多场合，比如：</p><ul><li>队列操作</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>BaseType_t <span class="token function">xQueueGenericSend</span><span class="token punctuation">(</span> QueueHandle_t xQueue<span class="token punctuation">,</span>
                              <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">const</span> pvItemToQueue<span class="token punctuation">,</span>
                              TickType_t xTicksToWait<span class="token punctuation">,</span>
                              <span class="token keyword">const</span> BaseType_t xCopyPosition <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    BaseType_t xEntryTimeSet <span class="token operator">=</span> pdFALSE<span class="token punctuation">,</span> xYieldRequired<span class="token punctuation">;</span>
    TimeOut_t xTimeOut<span class="token punctuation">;</span>
    Queue_t <span class="token operator">*</span> <span class="token keyword">const</span> pxQueue <span class="token operator">=</span> xQueue<span class="token punctuation">;</span>

    <span class="token function">configASSERT</span><span class="token punctuation">(</span> pxQueue <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">configASSERT</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pvItemToQueue <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pxQueue<span class="token operator">-&gt;</span>uxItemSize <span class="token operator">!=</span> <span class="token punctuation">(</span>UBaseType_t<span class="token punctuation">)</span><span class="token number">0U</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">configASSERT</span><span class="token punctuation">(</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>xCopyPosition <span class="token operator">==</span> queueOVERWRITE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>pxQueue<span class="token operator">-&gt;</span>uxLength <span class="token operator">!=</span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>中断级别的判断</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">vPortValidateInterruptPriority</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
	<span class="token class-name">uint32_t</span> ulCurrentInterrupt<span class="token punctuation">;</span>
	<span class="token class-name">uint8_t</span> ucCurrentPriority<span class="token punctuation">;</span>

	<span class="token comment">/* Obtain the number of the currently executing interrupt. */</span>
	ulCurrentInterrupt <span class="token operator">=</span> <span class="token function">vPortGetIPSR</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">/* Is the interrupt number a user defined interrupt? */</span>
	<span class="token keyword">if</span><span class="token punctuation">(</span> ulCurrentInterrupt <span class="token operator">&gt;=</span> portFIRST_USER_INTERRUPT_NUMBER <span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		<span class="token comment">/* Look up the interrupt&#39;s priority. */</span>
		ucCurrentPriority <span class="token operator">=</span> pcInterruptPriorityRegisters<span class="token punctuation">[</span> ulCurrentInterrupt <span class="token punctuation">]</span><span class="token punctuation">;</span>
	
		<span class="token function">configASSERT</span><span class="token punctuation">(</span> ucCurrentPriority <span class="token operator">&gt;=</span> ucMaxSysCallPriority <span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_18-1-3-trace" tabindex="-1"><a class="header-anchor" href="#_18-1-3-trace" aria-hidden="true">#</a> 18.1.3 Trace</h3><p>FreeRTOS中定义了很多trace开头的宏，这些宏被放在系统个关键位置。</p><p>它们一般都是空的宏，这不会影响代码：不影响编程处理的程序大小、不影响运行时间。</p><p>我们要调试某些功能时，可以修改宏：修改某些标记变量、打印信息等待。</p><table><thead><tr><th><strong>trace宏</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>traceTASK_INCREMENT_TICK(xTickCount)</td><td>当tick计数自增之前此宏函数被调用。参数xTickCount当前的Tick值，它还没有增加。</td></tr><tr><td>traceTASK_SWITCHED_OUT()</td><td>vTaskSwitchContext中，把当前任务切换出去之前调用此宏函数。</td></tr><tr><td>traceTASK_SWITCHED_IN()</td><td>vTaskSwitchContext中，新的任务已经被切换进来了，就调用此函数。</td></tr><tr><td>traceBLOCKING_ON_QUEUE_RECEIVE(pxQueue)</td><td>当正在执行的当前任务因为试图去读取一个空的队列、信号或者互斥量而进入阻塞状态时，此函数会被立即调用。参数pxQueue保存的是试图读取的目标队列、信号或者互斥量的句柄，传递给此宏函数。</td></tr><tr><td>traceBLOCKING_ON_QUEUE_SEND(pxQueue)</td><td>当正在执行的当前任务因为试图往一个已经写满的队列或者信号或者互斥量而进入了阻塞状态时，此函数会被立即调用。参数pxQueue保存的是试图写入的目标队列、信号或者互斥量的句柄，传递给此宏函数。</td></tr><tr><td>traceQUEUE_SEND(pxQueue)</td><td>当一个队列或者信号发送成功时，此宏函数会在内核函数xQueueSend(),xQueueSendToFront(),xQueueSendToBack(),以及所有的信号give函数中被调用，参数pxQueue是要发送的目标队列或信号的句柄，传递给此宏函数。</td></tr><tr><td>traceQUEUE_SEND_FAILED(pxQueue)</td><td>当一个队列或者信号发送失败时，此宏函数会在内核函数xQueueSend(),xQueueSendToFront(),xQueueSendToBack(),以及所有的信号give函数中被调用，参数pxQueue是要发送的目标队列或信号的句柄，传递给此宏函数。</td></tr><tr><td>traceQUEUE_RECEIVE(pxQueue)</td><td>当读取一个队列或者接收信号成功时，此宏函数会在内核函数xQueueReceive()以及所有的信号take函数中被调用，参数pxQueue是要接收的目标队列或信号的句柄，传递给此宏函数。</td></tr><tr><td>traceQUEUE_RECEIVE_FAILED(pxQueue)</td><td>当读取一个队列或者接收信号失败时，此宏函数会在内核函数xQueueReceive()以及所有的信号take函数中被调用，参数pxQueue是要接收的目标队列或信号的句柄，传递给此宏函数。</td></tr><tr><td>traceQUEUE_SEND_FROM_ISR(pxQueue)</td><td>当在中断中发送一个队列成功时，此函数会在xQueueSendFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。</td></tr><tr><td>traceQUEUE_SEND_FROM_ISR_FAILED(pxQueue)</td><td>当在中断中发送一个队列失败时，此函数会在xQueueSendFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。</td></tr><tr><td>traceQUEUE_RECEIVE_FROM_ISR(pxQueue)</td><td>当在中断中读取一个队列成功时，此函数会在xQueueReceiveFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。</td></tr><tr><td>traceQUEUE_RECEIVE_FROM_ISR_FAILED(pxQueue)</td><td>当在中断中读取一个队列失败时，此函数会在xQueueReceiveFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。</td></tr><tr><td>traceTASK_DELAY_UNTIL()</td><td>当一个任务因为调用了vTaskDelayUntil()进入了阻塞状态的前一刻此宏函数会在vTaskDelayUntil()中被立即调用。</td></tr><tr><td>traceTASK_DELAY()</td><td>当一个任务因为调用了vTaskDelay()进入了阻塞状态的前一刻此宏函数会在vTaskDelay中被立即调用。</td></tr></tbody></table><h3 id="_18-1-4-malloc-hook函数" tabindex="-1"><a class="header-anchor" href="#_18-1-4-malloc-hook函数" aria-hidden="true">#</a> 18.1.4 Malloc Hook函数</h3><p>编程时，一般的逻辑错误都容易解决。难以处理的是内存越界、栈溢出等。</p><p>内存越界经常发生在堆的使用过程总：堆，就是使用malloc得到的内存。</p><p>并没有很好的方法检测内存越界，但是可以提供一些回调函数：</p><ul><li>使用pvPortMalloc失败时，如果在FreeRTOSConfig.h里配置configUSE_MALLOC_FAILED_HOOK为1，会调用：</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">vApplicationMallocFailedHook</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_18-1-5-栈溢出hook函数" tabindex="-1"><a class="header-anchor" href="#_18-1-5-栈溢出hook函数" aria-hidden="true">#</a> 18.1.5 栈溢出Hook函数</h3><p>在切换任务(vTaskSwitchContext)时调用taskCHECK_FOR_STACK_OVERFLOW来检测栈是否溢出，如果溢出会调用：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">vApplicationStackOverflowHook</span><span class="token punctuation">(</span> TaskHandle_t xTask<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> pcTaskName <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>怎么判断栈溢出？有两种方法：</p><ul><li>方法1： <ul><li>当前任务被切换出去之前，它的整个运行现场都被保存在栈里，这时很可能就是它对栈的使用到达了峰值。</li><li>这方法很高效，但是并不精确</li><li>比如：任务在运行过程中调用了函数A大量地使用了栈，调用完函数A后才被调度。</li></ul></li></ul><p><img src="https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-18/image1.png" alt=""></p><ul><li>方法2： <ul><li>创建任务时，它的栈被填入固定的值，比如：0xa5</li><li>检测栈里最后16字节的数据，如果不是0xa5的话表示栈即将、或者已经被用完了</li><li>没有方法1快速，但是也足够快</li><li>能捕获几乎所有的栈溢出</li><li>为什么是几乎所有？可能有些函数使用栈时，非常凑巧地把栈设置为0xa5：几乎不可能</li></ul></li></ul><p><img src="https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-18/image2.png" alt=""></p><h2 id="_18-2-优化" tabindex="-1"><a class="header-anchor" href="#_18-2-优化" aria-hidden="true">#</a> 18.2 优化</h2><p>在Windows中，当系统卡顿时我们可以查看任务管理器找到最消耗CPU资源的程序。</p><p>在FreeRTOS中，我们也可以查看任务使用CPU的情况、使用栈的情况，然后针对性地进行优化。</p><p>这就是查看&quot;任务的统计&quot;信息。</p><h3 id="_18-2-1-栈使用情况" tabindex="-1"><a class="header-anchor" href="#_18-2-1-栈使用情况" aria-hidden="true">#</a> 18.2.1 栈使用情况</h3><p>在创建任务时分配了栈，可以填入固定的数值比如0xa5，以后可以使用以下函数查看&quot;栈的高水位&quot;，也就是还有多少空余的栈空间：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>UBaseType_t <span class="token function">uxTaskGetStackHighWaterMark</span><span class="token punctuation">(</span> TaskHandle_t xTask <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>原理是：从栈底往栈顶逐个字节地判断，它们的值持续是0xa5就表示它是空闲的。 函数说明：</p><table><thead><tr><th><strong>参数/返回值</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>xTask</td><td>哪个任务</td></tr><tr><td>返回值</td><td>任务运行时、任务被切换时，都会用到栈。栈里原来值(0xa5)就会被覆盖。 逐个函数从栈的尾部判断栈的值连续为0xa5的个数， 它就是任务运行过程中空闲内存容量的最小值。 注意：假设从栈尾开始连续为0xa5的栈空间是N字节，返回值是N/4。</td></tr></tbody></table><h3 id="_18-2-2-任务运行时间统计" tabindex="-1"><a class="header-anchor" href="#_18-2-2-任务运行时间统计" aria-hidden="true">#</a> 18.2.2 任务运行时间统计</h3><p>对于同优先级的任务，它们按照时间片轮流运行：你执行一个Tick，我执行一个Tick。</p><p>是否可以在Tick中断函数中，统计当前任务的累计运行时间？</p><p>不行！很不精确，因为有更高优先级的任务就绪时，当前任务还没运行一个完整的Tick就被抢占了。</p><p>我们需要比Tick更快的时钟，比如Tick周期时1ms，我们可以使用另一个定时器，让它发生中断的周期时0.1ms甚至更短。</p><p>使用这个定时器来衡量一个任务的运行时间，原理如下图所示：</p><p><img src="https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-18/image3.png" alt=""></p><ul><li>切换到Task1时，使用更快的定时器记录当前时间T1</li><li>Task1被切换出去时，使用更快的定时器记录当前时间T4</li><li>(T4-T1)就是它运行的时间，累加起来</li><li>关键点：在vTaskSwitchContext函数中，使用更快的定时器统计运行时间</li></ul><h3 id="_18-2-3-涉及的代码" tabindex="-1"><a class="header-anchor" href="#_18-2-3-涉及的代码" aria-hidden="true">#</a> 18.2.3 涉及的代码</h3><ul><li>配置</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">configGENERATE_RUN_TIME_STATS</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">configUSE_TRACE_FACILITY</span>    <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">configUSE_STATS_FORMATTING_FUNCTIONS</span>  <span class="token expression"><span class="token number">1</span></span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>实现宏portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()，它用来初始化更快的定时器</li><li>实现这两个宏之一，它们用来返回当前时钟值(更快的定时器) <ul><li>portGET_RUN_TIME_COUNTER_VALUE()：直接返回时钟值</li><li>portALT_GET_RUN_TIME_COUNTER_VALUE(Time)：设置Time变量等于时钟值</li></ul></li></ul><p>代码执行流程：</p><ul><li>初始化更快的定时器：启动调度器时</li></ul><p><img src="https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-18/image4.png" alt=""></p><p>在任务切换时统计运行时间</p><p><img src="https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-18/image5.png" alt=""></p><ul><li>获得统计信息，可以使用下列函数 <ul><li>uxTaskGetSystemState：对于每个任务它的统计信息都放在一个TaskStatus_t结构体里</li><li>vTaskList：得到的信息是可读的字符串，比如</li><li>vTaskGetRunTimeStats： 得到的信息是可读的字符串</li></ul></li></ul><h3 id="_18-2-4-函数说明" tabindex="-1"><a class="header-anchor" href="#_18-2-4-函数说明" aria-hidden="true">#</a> 18.2.4 函数说明</h3><ul><li>uxTaskGetSystemState：获得任务的统计信息</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>UBaseType_t <span class="token function">uxTaskGetSystemState</span><span class="token punctuation">(</span> TaskStatus_t <span class="token operator">*</span> <span class="token keyword">const</span> pxTaskStatusArray<span class="token punctuation">,</span>
                                        <span class="token keyword">const</span> UBaseType_t uxArraySize<span class="token punctuation">,</span>
                                        <span class="token class-name">uint32_t</span> <span class="token operator">*</span> <span class="token keyword">const</span> pulTotalRunTime <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>pxTaskStatusArray</td><td>指向一个TaskStatus_t结构体数组，用来保存任务的统计信息。 有多少个任务？可以用*uxTaskGetNumberOfTasks()*来获得。</td></tr><tr><td>uxArraySize</td><td>数组大小、数组项个数，必须大于或等于<em>uxTaskGetNumberOfTasks()</em></td></tr><tr><td>pulTotalRunTime</td><td>用来保存当前总的运行时间(更快的定时器)，可以传入NULL</td></tr><tr><td>返回值</td><td>传入的pxTaskStatusArray数组，被设置了几个数组项。 注意：如果传入的uxArraySize小于<em>uxTaskGetNumberOfTasks()</em>，返回值就是0</td></tr></tbody></table><ul><li>vTaskList ：获得任务的统计信息，形式为可读的字符串。注意，pcWriteBuffer必须足够大。 void vTaskList( signed char *pcWriteBuffer ); 可读信息格式如下：</li></ul><p><img src="https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-18/image6.png" alt=""></p><ul><li>vTaskGetRunTimeStats：获得任务的运行信息，形式为可读的字符串。注意，pcWriteBuffer必须足够大。</li></ul><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">vTaskGetRunTimeStats</span><span class="token punctuation">(</span> <span class="token keyword">signed</span> <span class="token keyword">char</span> <span class="token operator">*</span>pcWriteBuffer <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>可读信息格式如下：</p><p><img src="https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-18/image7.png" alt="image7"></p><h2 id="_18-3-示例25-统计单个任务的栈信息" tabindex="-1"><a class="header-anchor" href="#_18-3-示例25-统计单个任务的栈信息" aria-hidden="true">#</a> 18.3 示例25: 统计单个任务的栈信息</h2><p>本节代码为：1801_stack_state，主要看applications\\led_app.c。</p><p>在src\\user_tasks_entry.c中在创建LED任务时，设置的栈大小为128*4，代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token number">31</span> <span class="token function">xTaskCreate</span><span class="token punctuation">(</span>led_thread_entry<span class="token punctuation">,</span> <span class="token string">&quot;led_task&quot;</span><span class="token punctuation">,</span> <span class="token number">128</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个栈是否太大了？可以在LED任务中打印栈信息，代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token number">09</span> <span class="token keyword">void</span> <span class="token function">led_thread_entry</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> pvParameters<span class="token punctuation">)</span>
<span class="token number">10</span> <span class="token punctuation">{</span>
<span class="token number">11</span>     <span class="token comment">/* TODO: add your own code here */</span>
<span class="token number">12</span>     UBaseType_t freeNum<span class="token punctuation">;</span>
<span class="token number">13</span>     TaskHandle_t xTaskHandle<span class="token punctuation">;</span>
<span class="token comment">/* 省略 */</span>
<span class="token number">20</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">21</span>     <span class="token punctuation">{</span>
<span class="token number">22</span>         xTaskHandle <span class="token operator">=</span> <span class="token function">xTaskGetCurrentTaskHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">23</span>         freeNum <span class="token operator">=</span> <span class="token function">uxTaskGetStackHighWaterMark</span><span class="token punctuation">(</span>xTaskHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">24</span>         <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;FreeStack of Task %s : %d\\n\\r&quot;</span><span class="token punctuation">,</span> <span class="token function">pcTaskGetName</span><span class="token punctuation">(</span>xTaskHandle<span class="token punctuation">)</span><span class="token punctuation">,</span> freeNum<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">25</span>
<span class="token number">26</span>         pLedDev<span class="token operator">-&gt;</span><span class="token function">Write</span><span class="token punctuation">(</span>pLedDev<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">27</span>         state <span class="token operator">=</span> <span class="token operator">!</span>state<span class="token punctuation">;</span>
<span class="token number">28</span>         <span class="token function">R_BSP_SoftwareDelay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">,</span> BSP_DELAY_UNITS_MILLISECONDS<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">29</span>     <span class="token punctuation">}</span>
<span class="token number">30</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第22行：获得当前任务的句柄。 第23行：获得当前任务的“栈高水位”，即：freeNum为空闲栈大小（单位为4字节）。 第24行：打印。</p><p>需要使用RASC进行配置，uxTaskGetStackHighWaterMark才会被使能，如下操作：</p><p><img src="https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-18/image8.png" alt="image8"></p><p>实验现象：在串口打印如下栈信息。如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code>FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">70</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">70</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">68</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">68</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">68</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">68</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">68</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">68</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">68</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">68</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">68</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">68</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">66</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">66</span>
FreeStack of Task led_task <span class="token operator">:</span> <span class="token number">66</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当程序运行足够长时间后，栈信息就稳定了。根据上述信息，在创建LED任务时可以把栈设置得小一点。原来的栈大小为128，剩余66，那么128-66= 62就够用了。当然不要那么严格，否则在LED任务里稍微增加一个局部变量、甚至稍微调整编译优化等级，都可能导致栈不够用。建议栈大小为实际使用量的1.5倍、2倍。</p><h2 id="_18-4-示例26-统计所有任务的栈信息" tabindex="-1"><a class="header-anchor" href="#_18-4-示例26-统计所有任务的栈信息" aria-hidden="true">#</a> 18.4 示例26: 统计所有任务的栈信息</h2><p>本节代码为：1802_all_stack_state，主要看src\\user_tasks_entry.c。</p><p>要打印所有任务的栈信息，在空闲任务里进行最合适。需要实现空闲任务的钩子函数vApplicationIdleHook。</p><p>先在RASC里使能这个钩子函数和其他统计函数，如下操作：</p><p><img src="https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-18/image9.png" alt="image9"></p><p>然后在src\\user_tasks_entry.c中实现空闲任务钩子函数，代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token number">40</span>                 <span class="token keyword">void</span> <span class="token function">vApplicationIdleHook</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span>
<span class="token number">41</span>                 <span class="token punctuation">{</span>
<span class="token number">42</span>                     <span class="token keyword">static</span> <span class="token keyword">signed</span> <span class="token keyword">char</span> pcWriteBuffer<span class="token punctuation">[</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token number">43</span>                      <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token number">44</span>                      <span class="token function">vTaskList</span><span class="token punctuation">(</span>pcWriteBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">45</span>                      <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">16</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token number">46</span>                              <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;-&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">47</span>                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;\\n\\r&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">48</span>                      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\\n\\r&quot;</span><span class="token punctuation">,</span> pcWriteBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">49</span>                 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当运行这个程序时，发现串口上并没有打印信息，这表示空闲任务一直无法运行。原因是LED任务的延时函数是“死循环等待”，导致LED任务不阻塞，而LED任务的优先级比空闲任务高，所以空闲任务无法运行。如需修改applications\\led_app.c：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token number">20</span>     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token number">21</span>     <span class="token punctuation">{</span>
<span class="token number">22</span>         <span class="token comment">//xTaskHandle = xTaskGetCurrentTaskHandle();</span>
<span class="token number">23</span>         <span class="token comment">//freeNum = uxTaskGetStackHighWaterMark(xTaskHandle);</span>
<span class="token number">24</span>         <span class="token comment">//printf(&quot;FreeStack of Task %s : %d\\n\\r&quot;, pcTaskGetName(xTaskHandle), freeNum);</span>
<span class="token number">25</span>
<span class="token number">26</span>         pLedDev<span class="token operator">-&gt;</span><span class="token function">Write</span><span class="token punctuation">(</span>pLedDev<span class="token punctuation">,</span> state<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">27</span>         state <span class="token operator">=</span> <span class="token operator">!</span>state<span class="token punctuation">;</span>
<span class="token number">28</span>         <span class="token comment">//R_BSP_SoftwareDelay(500, BSP_DELAY_UNITS_MILLISECONDS);</span>
<span class="token number">29</span>         <span class="token function">vTaskDelay</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">30</span>     <span class="token punctuation">}</span>
<span class="token number">31</span> <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>把第28行注释掉，改为第29行。</p><p>实验现象：在串口上打印出任务信息。如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
IDLE            X       <span class="token number">0</span>       <span class="token number">52</span>      <span class="token number">2</span>
game1_task      B       <span class="token number">1</span>       <span class="token number">94</span>      <span class="token number">6</span>
led_task        B       <span class="token number">1</span>       <span class="token number">106</span>     <span class="token number">5</span>
Tmr Svc         B       <span class="token number">1</span>       <span class="token number">28</span>      <span class="token number">3</span>
touch_task      B       <span class="token number">1</span>       <span class="token number">54</span>      <span class="token number">4</span>
platform_task   B       <span class="token number">1</span>       <span class="token number">206</span>     <span class="token number">9</span>
InputTask       B       <span class="token number">1</span>       <span class="token number">86</span>      <span class="token number">8</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第1列是任务名，第2列是任务状态，第3列是任务优先级，第4列是空闲栈大小，第5列是任务编号。 以led_task为例，它的空闲栈是106，跟1801_stack_state相比，本工程里led_task没有使用printf，所以栈的消耗更小。</p><h2 id="_18-5-示例27-统计任务cpu占用率" tabindex="-1"><a class="header-anchor" href="#_18-5-示例27-统计任务cpu占用率" aria-hidden="true">#</a> 18.5 示例27: 统计任务CPU占用率</h2><p>本节代码为：1803_cpu_usage，主要看src\\user_tasks_entry.c。</p><p>要带你所有任务的栈信息，在空闲任务里进行最合适。需要实现空闲任务的钩子函数vApplicationIdleHook。</p><p>先在RASC里使能这个钩子函数和其他统计函数，如下操作：</p><p><img src="https://photos.100ask.net/renesas-docs/DShanMCU_RA6M5/FreeRTOS/chapter-18/image10.png" alt="image10"></p><p>然后在src\\user_tasks_entry.c中实现空闲任务钩子函数，代码如下：</p><div class="language-c40 line-numbers-mode" data-ext="c40"><pre class="language-c40"><code>41                 {
42                     static signed char pcWriteBuffer[200];
43                      int i;
44                      //vTaskList(pcWriteBuffer);
45                      vTaskGetRunTimeStats(pcWriteBuffer);
46                      for (i = 0; i &lt; 16; i++)
47                              printf(&quot;-&quot;);
48                      printf(&quot;\\n\\r&quot;);
49                      printf(&quot;%s\\n\\r&quot;, pcWriteBuffer);
50                 }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第45行：获得各个任务的CPU占用率。</p><p>要想使用vTaskGetRunTimeStats，需要提供更精确的读取时间函数，我们已经有了“system_get_us”函数，只需要修</p><p>改“ra\\aws\\FreeRTOS\\FreeRTOS\\Source\\include\\FreeRTOS.h”，代码如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token number">759</span> #<span class="token keyword">if</span> <span class="token punctuation">(</span> configGENERATE_RUN_TIME_STATS <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span>
<span class="token number">760</span>
<span class="token number">761</span>     #define <span class="token function">portCONFIGURE_TIMER_FOR_RUN_TIME_STATS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token number">762</span>     #define <span class="token function">portGET_RUN_TIME_COUNTER_VALUE</span><span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token function">system_get_us</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实验现象：在串口上打印出任务信息。如下：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
IDLE            <span class="token number">263399270</span>               <span class="token number">68</span><span class="token operator">%</span>
game1_task      <span class="token number">20115760</span>                <span class="token number">5</span><span class="token operator">%</span>
led_task        <span class="token number">10</span>              <span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">%</span>
Tmr Svc         <span class="token number">5030370</span>         <span class="token number">1</span><span class="token operator">%</span>
touch_task      <span class="token number">94024730</span>                <span class="token number">24</span><span class="token operator">%</span>
platform_task   <span class="token number">150</span>             <span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">%</span>
InputTask       <span class="token number">10</span>              <span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">%</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到touch_ask的CPU占用率太高了。它使用查询的方式不断读取触摸屏数据，平时不操作触摸屏时也会读取。可以改进这任务，让它平时阻塞，当点击触摸屏产生中断时，在中断里把任务唤醒。</p>`,117),c=[p];function o(i,l){return s(),a("div",null,c)}const r=n(t,[["render",o],["__file","chapter18.html.vue"]]);export{r as default};
